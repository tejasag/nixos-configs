#!/nix/store/30j23057fqnnc1p4jqmq73p0gxgn0frq-bash-5.1-p16/bin/bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
h_usage() {
  if [[ -n $long_usage ]]; then
    printf "h - H (or Hydrogen) is a CLI with a bunch of utilities.\n"
    echo

  else
    printf "h - H (or Hydrogen) is a CLI with a bunch of utilities.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  h [command]\n"
  printf "  h [command] --help | -h\n"
  printf "  h --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  rebuild   Rebuild NixOS or home-manager"
  echo "  update    Update flake inputs"
  echo "  test      Rebuild and test the system"
  echo "  search    Search for a package in nixpkgs"
  echo "  shell     Setup files for an adhoc shell in the directory"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
h_rebuild_usage() {
  if [[ -n $long_usage ]]; then
    printf "h rebuild - Rebuild NixOS or home-manager\n"
    echo

  else
    printf "h rebuild - Rebuild NixOS or home-manager\n"
    echo

  fi

  printf "Shortcut: re\n"
  echo

  printf "Usage:\n"
  printf "  h rebuild [MODULE]\n"
  printf "  h rebuild --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  MODULE"
    printf "    Module to rebuild.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  h rebuild\n"
    printf "  h re\n"
    printf "  h re hm\n"
    echo

  fi
}

# :command.usage
h_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "h update - Update flake inputs\n"
    echo

  else
    printf "h update - Update flake inputs\n"
    echo

  fi

  printf "Shortcut: u\n"
  echo

  printf "Usage:\n"
  printf "  h update [INPUT]\n"
  printf "  h update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  INPUT"
    printf "    Inputs to update\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  h update\n"
    printf "  h u\n"
    printf "  h u nixpkgs\n"
    echo

  fi
}

# :command.usage
h_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "h test - Rebuild and test the system\n"
    echo

  else
    printf "h test - Rebuild and test the system\n"
    echo

  fi

  printf "Shortcut: t\n"
  echo

  printf "Usage:\n"
  printf "  h test\n"
  printf "  h test --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  h test\n"
    printf "  h t\n"
    echo

  fi
}

# :command.usage
h_search_usage() {
  if [[ -n $long_usage ]]; then
    printf "h search - Search for a package in nixpkgs\n"
    echo

  else
    printf "h search - Search for a package in nixpkgs\n"
    echo

  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  h search PACKAGE\n"
  printf "  h search --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    Package to search for\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  h search emacs\n"
    printf "  h s neovim\n"
    echo

  fi
}

# :command.usage
h_shell_usage() {
  if [[ -n $long_usage ]]; then
    printf "h shell - Setup files for an adhoc shell in the directory\n"
    echo

  else
    printf "h shell - Setup files for an adhoc shell in the directory\n"
    echo

  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  h shell PACKAGES...\n"
  printf "  h shell --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGES..."
    printf "    Packages to add to the shell\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  h s hello\n"
    printf "  h shell hello\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
#

#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# src/lib/logger.sh
info() { printf "$(yellow_bold [HYDROGEN]) $(yellow $1)"; }
error() { printf "$(red_bold [HYDROGEN]) $(red_underlined FAILED) $(red $1)\n"; }
success() { printf "$(green_bold [HYDROGEN]) $(green $1)\n"; }

# :command.command_functions
# :command.function
h_rebuild_command() {
  # src/rebuild_command.sh
  mod=${args[module]}

  if [ "$mod" == "hm" ] || [ "$mod" == "home-manager" ]; then
      info "Rebuilding Home-Manager configurations...\n"
      RESULT=$(~/.dotfiles/scripts/apply-user.sh 2>&1)
      if echo "${RESULT}" | grep "error"; then
          echo "${RESULT}" | awk 'NR==10{exit} $1 ~ /at.*|[0-9]+|\|/'

          error 'Could not rebuild the home-manager configurations.'
      else
         success 'Successfully rebuilt and switched the home-manager configurations!'
      fi
  else
      info "Rebuilding NixOS configurations...\n"
      RESULT=$(~/.dotfiles/scripts/apply-system.sh 2>&1)
      if echo "${RESULT}" | grep "error"; then
          echo "${RESULT}" | awk '$1 ~ /at.*|[0-9]+|\|/'

          error 'Could not rebuild the system configurations.'
      else
         success 'Successfully rebuilt and switched the system configurations!'
      fi
  fi
}

# :command.function
h_update_command() {
  # src/update_command.sh
  input=${args[input]}

  pushd ~/.dotfiles
  if [ $input ]; then
      info "Updating the '$input' input..."
      RESULT=$(nix flake lock --impure --update-input $input)
      success "Successfully updated the '$input' flake!"
  else
      info "Updating all inputs..."
      RESULT=$(nix flake update --impure)
      success "Successfully updated all inputs!"
  fi
  popd
}

# :command.function
h_test_command() {
  # src/test_command.sh
  info "Rebuilding NixOS configurations in TESTING MODE...\n"
  RESULT=$(~/.dotfiles/scripts/test-system.sh 2>&1)
  if echo "${RESULT}" | grep "error"; then
      echo "${RESULT}" | awk '$1 ~ /at.*|[0-9]+|\|/'

      error 'Could not rebuild the system configurations.'
  else
     success 'Successfully rebuilt and switched the system configurations!'
  fi
}

# :command.function
h_search_command() {
  # src/search_command.sh
  #echo "# this file is located in 'src/search_command.sh'"
  #echo "# code for 'h search' goes here"
  #echo "# you can edit it freely and regenerate (it will not be overwritten)"
  #inspect_args
  pkg=${args[package]}
  info "Searching the Nix repositories...."
  nix search nixpkgs $pkg
}

# :command.function
h_shell_command() {
  # src/shell_command.sh
  pkgs=''
  eval "pkgs=(${args[packages]})"
  final=''

  [ -f shell.nix ] && error "shell.nix already exists." && exit 1

  for i in "${pkgs[@]}"; do
    final+=" "
    final+=$i
  done

  echo " { pkgs ? import <nixpkgs> {}}:
  pkgs.mkShell {
    nativeBuildInputs = with pkgs; [ $final ];
  }" >> shell.nix

  echo "use nix" >> .envrc

  direnv allow

  success "Done! Added the following packages:\n$final"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    h_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  rebuild | re )
    action="rebuild"
    shift
    h_rebuild_parse_requirements "$@"
    shift $#
    ;;

  update | u )
    action="update"
    shift
    h_update_parse_requirements "$@"
    shift $#
    ;;

  test | t )
    action="test"
    shift
    h_test_parse_requirements "$@"
    shift $#
    ;;

  search | s )
    action="search"
    shift
    h_search_parse_requirements "$@"
    shift $#
    ;;

  shell | s )
    action="shell"
    shift
    h_shell_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    h_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
h_rebuild_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    h_rebuild_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="rebuild"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[module]+x} ]]; then
        # :argument.validations
        args[module]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
h_update_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    h_update_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="update"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[input]+x} ]]; then
        # :argument.validations
        args[input]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
h_test_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    h_test_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="test"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
h_search_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    h_search_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="search"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[package]+x} ]]; then
        # :argument.validations
        args[package]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[package]+x} ]]; then
    printf "missing required argument: PACKAGE\nusage: h search PACKAGE\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
h_shell_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    h_shell_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="shell"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[packages]+x} ]]; then
        # :argument.validations
        args[packages]="\"$1\""
        shift
      else
        args[packages]="${args[packages]} \"$1\""
        shift
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[packages]+x} ]]; then
    printf "missing required argument: PACKAGES\nusage: h shell PACKAGES...\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.1.1"
  long_usage=''
  set -e

  # src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "rebuild" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      h_rebuild_usage
    else
      h_rebuild_command
    fi

  elif [[ $action == "update" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      h_update_usage
    else
      h_update_command
    fi

  elif [[ $action == "test" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      h_test_usage
    else
      h_test_command
    fi

  elif [[ $action == "search" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      h_search_usage
    else
      h_search_command
    fi

  elif [[ $action == "shell" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      h_shell_usage
    else
      h_shell_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
